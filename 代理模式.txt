代理模式主要有两个目的：
    1.保护目标对象;
    2.增强目标对象

静态代理：
    静态代理的实现比较简单，代理类通过实现与目标对象相同的接口，并在类中维护一个代理对象。
    通过构造器塞入目标对象，赋值给代理对象，进而执行代理对象实现的接口方法，并实现前拦截，后拦截等所需的业务功能。

    优点：
        可以做到不对目标对象进行修改的前提下，对目标对象进行功能的扩展和拦截。
    缺点：
        1.一个代理类只能代理一类对象
        2.需要代理多类对象，要实现多个代理类，造成代理类的膨胀，难以维护

动态代理：
    动态代理是指动态的在内存中构建代理对象
    优点：
        代理对象无需实现接口，免去了编写很多代理类的烦恼，同时接口增加方法也无需再维护目标对象和代理对象，只需在事件处理器中添加对方法的判断即可。
    缺点：
        代理对象不需要实现接口，但是目标对象一定要实现接口，否则无法使用JDK动态代理。

    JDK动态代理：
        JDK Proxy 采用字节重组，重新生的对象来替代原始的对象以达到动态代理的目的。JDK Proxy 生成对象的步骤如下：
            1、拿到被代理对象的引用，并且获取到它的所有的接口，反射获取。
            2、JDK Proxy 类重新生成一个新的类、同时新的类要实现被代理类所有实现的所有的接口。
            3、动态生成 Java 代码，把增强逻辑加入新生代码中。
            4、编译新生成的 Java 代码.class。
            5、加载并重新运行新的class，得到的类就是全新的类

    Cglib动态代理：
        CGLib 代理的目标对象不需要实现任何接口，它是通过动态继承目标对象实现的动态代理


    CGLib 和 JDK 动态代理对比
    1.JDK 动态代理是实现了被代理对象的接口（目标类相对复杂），CGLib 是继承了被代理对象。
    2.JDK 和 CGLib 都是在运行期生成字节码，JDK 是直接写 Class 字节码，CGLib 使用 ASM框架写 Class 字节码，Cglib 代理实现更复杂，生成代理类比 JDK 效率低。
    3.JDK 调用代理方法，是通过反射机制调用，CGLib 是通过 FastClass 机制直接调用方法，CGLib 执行效率更高。
